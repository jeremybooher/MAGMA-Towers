/* Store and analyze results of computations
Towers are stored as:
tower := <info, data>

info: p,d, description of tower, #levels computed, # powers computed, time spent (in seconds)
data : list of [ genus , dim ker V^1, dim ker V^2, ...] 
*/ 

//display the tower
procedure show_entry(tower)
	info := tower[1];
	data := tower[2];
	print "Tower:", info[3];
	print "p=",info[1],"d=",info[2];
	print "Levels:",info[4];
	print "Genus, dim Ker V, dim Ker V^2...";
	for row in data do
		print row;
	end for;
	print "";
end procedure;

//get p
function get_characteristic(tower)
	return tower[1][1];
end function;

//get d, the ramification invariant of the first level of the tower
//for basic towers, this is also the ramification invariant of the tower
function get_ramification_invariant(tower)
	return tower[1][2];
end function;

//get description
function get_name(tower)
	return tower[1][3];
end function;

//get it in a format suitable for latex
function get_name_latex(tower)
	poly := tower[1][3];
	
	//some more complicated towers are just stored as a string.  If so, return it and hope
	if Type(poly) eq Type("abc") then
		return poly;
	end if;
	
	coeff := Coefficients(poly);
	d := #coeff-1;
	coeffstring := ""; if coeff[d+1] ne 1 then coeffstring:=Sprint(coeff[d+1]) ; end if;
	printstring := coeffstring * "x^{" * Sprint(d) * "}";
	
	while d gt 0 do
		d := d-1;
		c := coeff[d+1];
		if c ne 0 then
			coeffstring := ""; if c ne 1 then coeffstring:=Sprint(c) ; end if;
			printstring *:= " +"*coeffstring * "x^{" * Sprint(d) * "}";
		end if;
	end while;
	return printstring;
end function;

//get the a-number of tower at level, or optionally that for a power of Cartier
function get_anumber(tower,level : power:=1)
	assert (level le tower[1][4]);
	assert (power le tower[1][5]);
	return tower[2][level][power+1];
end function;

//get the a-numbers for all levels of the tower, or optioanll that of a power of Cartier
function get_anumbers(tower : power:=1)
	assert (power le tower[1][5]);
	return [ row[power+1] : row in tower[2] ];
end function;

//get dimension of ker V^{power} / ker V^{power-1} at the nth level
function get_gradeds(tower,power)
	assert (power le tower[1][5]);
	if power eq 1 then
		return get_anumbers(tower);
	end if;
	bigdims := get_anumbers(tower : power:=power);
	smalldims := get_anumbers(tower : power:=power-1);
	return [bigdims[n]-smalldims[n]  :  n in [1..#bigdims]];
end function;

//get dim ker V^r for a particular level
function get_invariants(tower,level)
	assert( level le tower[1][4]);
	return [tower[2][level][n+1] : n in [1..tower[1][5]]];
end function;

/* Functions to Analyze the Data */

/* Guess a formula 
a * q^(2n) + b * q^n + c = a(n)
based on q, three choices of n, and the assocaited a(n)
*/
guess:=function(q,ns, as)
	v:=Vector(Rationals(),as);
	N:=Matrix(Rationals(),[[ q^(2*n) , q^n , 1] : n in ns]);
	sol:=Solution(Transpose(N),v);
	return [ sol[1], sol[2], sol[3]];
end function;

//predict additional layers where coeff is a list of coefficients
//for example as produced by guess
predict := function(q,n,coeff)
	return coeff[1] * q^(2*n) + coeff[2] * q^(n) + coeff[3] ;
end function;

//guess a formula given p, the dimensions, and which level to start at
//return the coefficients of the formula, and a boolean indicating whether or not any additional data
//besides the three data points used to guess the formula is consistent
function auto_guess(p,vals,start)
	assert( #vals - start ge 0); //otherwise not enough data to guess
		
	v:=Vector(Rationals(),vals[start..(start+2)]);
	N:=Matrix(Rationals(),[[ p^(2*n) , p^n , 1] : n in [start..(start+2)]]);
	sol:=Solution(Transpose(N),v);
	coeff := [ sol[1], sol[2], sol[3]];
	for n in [start+3..#vals] do
		if predict(p,n,coeff) ne vals[n] then
			return coeff, false;
		end if;
	end for;
	
	return coeff,true;
end function;

//make and check a guess for the towers in data
procedure make_guesses(p,data : power:=1)
	for tower in data do
		vals := get_anumbers(tower : power:=power);
		coeff, bool := auto_guess(p,vals,2);
		
		print "Base a-number:",vals[1];
		print "Formula:", coeff[1] ,"*", p, "^(2n)+",coeff[2],"*",p,"^n+",coeff[3];
		print "Consistent?",bool;
	end for;
end procedure;

//compute alpha_r(d,p), the predicted leading term
function alpha(d,p : r:=1)
	return r * (p-1) * d / ( 2 * (p+1) * ( (p-1)*r + (p+1)));
end function;

//In char p >2, a-number level(n+1) = alpha(d,p) (p^(2 n) - p^2 )  + a-number level(1)
//This is too strong to be true
function conjecture1(p,d,tower)
	conjecture := true;
	
	vals := get_anumbers(tower : power:=1);
	
	a1 := vals[1];
	leading := alpha(d,p);
		
	for n in [2..#vals] do
		if leading * (p ^(2*n) - p^2) + a1 ne vals[n] then
			print n,"Predicted:", leading * (p ^(2*n) - p^2) + a1,"Actual:",vals[n];
			conjecture:=false;
		end if;
	end for;	

	return conjecture;	
end function;

//test conjecture1 for a list of towers
procedure test_conjecture1(towers)
	for tower in towers do
		p := get_characteristic(tower);
		d:= get_ramification_invariant(tower);
		name := get_name(tower);
		bool := conjecture1(p,d,tower);
		print "Conjecture1:",p,name,bool;
	end for;
end procedure;

function predict_leadingconstant(p,d,power)
	return alpha(d,p : r := power);
end function;

function leading_numerator(p,d,r)
	return Numerator(alpha(d,p : r:=r));
end function;

function leading_denominator(p,d,r)
	return Denominator(alpha(d,p : r:=r));
end function;

//predict alpha_r(1,p) i.e. the part independent of d.
function predict_leadingconstant_nod(p,r)
	return r * (p-1)  / ( 2 * (p+1) * ( (p-1)*r + (p+1)));
end function;

//pull out specific examples
function filter_data(data: p := -1 , d:= -1)
	new_data := [];
	for tower in data do
		if ( p eq -1 or p eq get_characteristic(tower)) and ( d eq -1 or d eq get_ramification_invariant(tower)) then
			Append(~new_data,tower);
		end if;
	end for;
	return new_data;
end function;

/*
Some attempts at predicting the formula
*/

//most basic guess, stable after level 1
// use (p ^(2*n) - p^2) to at least sometimes get an integer
//this needs power \equiv 1 \mod p to get an integer.  Otherwise would need congruence condition on n
function predict1(p,d,power,n,a1)
	return predict_leadingconstant(p,d,power)* (p ^(2*n) - p^2) + a1;
end function;

//stable after level, put in floor function to make sure integer
function predict2(p,d,power,n,level,alevel)
	return Floor( alpha(d,p : r:= power) * (p^(2*n) - p^(2 * level))) + alevel;
end function;

//floor of leading term
function predict_leading_floor(p,d,power,n)
	return Floor(predict_leadingconstant(p,d,power)* (p ^(2*n)));
end function;

//take into account first level, and just use floor 
function predict3(p,d,power,n,a1)
	return Floor(predict_leadingconstant(p,d,power)* (p ^(2*n))) +a1;
end function;

//try floor functions in a telescoping sum
/*
function predict4(p,d,power,n,level1)
	alpha := predict_leadingconstant(p,d,power);
	
	total := 0;
	for j in [2..n] do
		total +:= Ceiling( alpha *  (p ^(2*(j-1)) - p^(2 * (j-2))));
	end for;
	return total + level1;
end function;
*/

/*
the following look for all of the towers in data with given (p,d) without making any predictions
*/
procedure display_data(data,p,d )
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		for power in [1.. tower[1][5]] do
			vals := get_anumbers(tower : power:=power);
			print "dimensions of ker V^",power,":",vals;
		end for;
		
		print "";
	end for;
end procedure;

//look for all of the towers in data with given (p,d) and display some predictions and errors about the invariants
procedure display_predictions(data,p,d : power:=1 , startinglevel:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_anumbers(tower : power:=power);
		print "dimensions of ker V^",power,":",vals;
		pred1 := [ predict1(p,d,power,n,vals[1]) : n in [1..#vals]];
		print "Predictions1:",pred1;
		print "Delta1s:",[ vals[i] - pred1[i] : i in [1..#vals]];
		print "";

		pred2:= [ predict2(p,d,power,n,startinglevel,vals[startinglevel]) : n in [1..#vals]];
		print "Predictions2:",pred2;
		print "Delta2s:",[ vals[i] - pred2[i] : i in [1..#vals]];
		print "";

		pred3 := [ predict3(p,d,power,n,vals[1]) : n in [1..#vals]];
		print "Predictions3:",pred3;		
		print "Delta3s:",[ vals[i] - pred3[i] : i in [1..#vals]];
		print "--------------------";
		print "";
	end for;
end procedure;

//Try to look at difference from previous level to detect when the constant term changes
procedure display_differences(data,p,d : power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_anumbers(tower : power:=power);
		diffs := [vals[n]-vals[n-1] : n in [2..#vals]];
		print "Differences of ker V^",power,":",diffs;
		pred1 := [ predict_leadingconstant(p,d,power) * (p^2-1) * p^(2 *(n-1))  : n in [2..#vals]];
		print "Predictions:",pred1;
		print "Deltas:",[ diffs[i] - pred1[i] : i in [1..#vals-1]];
	end for;
end procedure;

//Try to look at gradeds.  Maybe they'll be nicer?  Not really
procedure display_gradeds(data,p,d , power)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_gradeds(tower , power);
		print "Dimension of gr ker V^",power,":",vals;
	end for;
end procedure;

//display all data for a given p, d in range 2->40
procedure display_lots_data(p)
	for d in [2..40] do
		if (d mod p ne 0) then
			print "Data for p=",p," d=",d;			
			display_data(p,d);
			print "";
		end if;
	end for;
end procedure;

/*Find instances for a given p, d where we don't have
a-number level n - a-number leven (n-1) = difference of the leading terms
In other words, the constant term has changed
data must already have been filtered to have correct d,p
*/
function find_discrepancies_d(p,d,data)
	discrep := {};
	for tower in data do
		assert( p eq get_characteristic(tower));
		assert( d eq get_ramification_invariant(tower));
		
		leading := alpha(d,p);
		vals := get_anumbers(tower : power:=1);

		for i in [2..#vals] do
			if vals[i] - vals[i-1] ne  leading * (p^2-1) * p^(2 *(i-1)) then
				Include(~discrep,i);
			end if;
		end for;
	end for;
	return discrep;
end function;

function find_discrepancies(p , max, data )
	return [ <d,find_discrepancies_d(p,d,filter_data(data : p:=p, d:= d)) > : d in [2..max] | (d mod p ne 0) ] ; 
end function;

/* Functions for Creating LaTeX tables
Requires the package booktabs for nicer formatting */
/*
\begin{table}[ht]
\centering
\begin{tabular}[c| c....c]
header
\toprule
labels & data
\bottomrule
\end{tabular}
\caption{ caption }
\end{table}
*/
function format_table(header,labels,data,caption)
	columns := #header;
	preamble := "\\begin{table}[ht]\n\\centering\n\\begin{tabular}{c|";
	
	for n in [1..columns] do
		preamble *:= "c ";
	end for;
	preamble *:= "}\n";
	
	headerstring := Sprint(header[1]);
	for n in [2..columns] do
		headerstring *:=" & " * Sprint(header[n]);
	end for;
	headerstring *:= " \\\\ \n\\toprule\n";
	
	mainstring := "";
	for n in [1..#labels] do
		rowstring := Sprint(labels[n]);
		for item in data[n] do
			rowstring *:= " & " * Sprint(item);
		end for;
		mainstring *:= rowstring * " \\\\ \n";
	end for;
	
	finalstring := "\\bottomrule\n\\end{tabular}\n\\caption{" * Sprint(caption) * "}\n\\end{table}";
	
	return preamble * headerstring * mainstring * finalstring;
end function;

//style 1, displaying genus, dim ker V^r
function tower_table1(tower : maxlevel:=1000, maxpower:=1000)
	info := tower[1];
	data := tower[2];
	levels := Min(info[4],maxlevel);
	powers := Min(info[5],maxpower);

	header := ["Level", "Genus"] cat [ "dim ker $V^{" *Sprint(n) *"}$": n in [1..powers]];
	
	labels := [1..levels];
	data := [  [data[l][r] : r in [1..powers+1]] : l in [1..levels] ];
	
	caption := "$y^F-y="*Sprint(get_name_latex(tower)) * "$ with $(p,d) = (" * Sprint(get_characteristic(tower))*"," * Sprint(get_ramification_invariant(tower)) * ")$";
	return format_table(header,labels,data,caption);
end function;

//style 2, with levels in columns
function tower_table2(tower : maxlevel:=1000, maxpower:=1000)
	info := tower[1];
	data := tower[2];
	levels := Min(info[4],maxlevel);
	powers := Min(info[5],maxpower);

	labels := [ "Genus"] cat [ "dim ker $V^{" *Sprint(n) *"}$": n in [1..powers]];
	
	header := ["Level:"] cat [ Sprint(n) : n in [1..levels]];
	data := [  [data[l][r] : l in [1..levels]] : r in [1..powers+1] ];
	
	caption := "$y^F-y="*Sprint(get_name_latex(tower)) * "$ with $(p,d) = (" * Sprint(get_characteristic(tower))*"," * Sprint(get_ramification_invariant(tower)) * ")$";
	return format_table(header,labels,data,caption);
end function;


//make tables displaying predictions for values
procedure table_data(data,p,d: power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do	
		info := tower[1];
		data := tower[2];
		levels := info[4];

		labels := [ "Actual", "Pred1","Pred2","Delta2","Pred3","Delta3"];
		
		header := ["Level:"] cat [ Sprint(n) : n in [1..levels]];
		vals:=get_anumbers(tower : power:=power) ;
		pred1 := [ predict1(p,d,power,n,vals[1]) : n in [1..#vals]];
		pred2 := [ predict2(p,d,power,n) : n in [1..#vals]];
		pred3 := [ predict3(p,d,power,n,vals[1]) : n in [1..#vals]];
		data := [ vals, pred1,pred2,
			[ vals[i] - pred2[i] : i in [1..#vals]],
			pred3, [ vals[i] - pred3[i] : i in [1..#vals]]
			];

		
		caption := "$y^F-y="*Sprint(get_name_latex(tower)) * "$ with $(p,d) = (" * Sprint(get_characteristic(tower))*"," * Sprint(get_ramification_invariant(tower)) * ")$";
		print format_table(header,labels,data,caption);
		print "";
	end for;
end procedure;

/*
In case same computation gets run multiple times (with different depth perhaps), remove duplicates
*/
remove_duplicate_data := function(data)
	accumulated_towers := AssociativeArray();
	for tower in data do
		p := get_characteristic(tower);
		poly := get_name(tower);
		key := <p,poly>;
		if key in Keys(accumulated_towers) then
			Append(~accumulated_towers[key],tower);
			print "Had duplicate:",key;
			print "";
		else
			accumulated_towers[key] := [tower];
		end if;
	end for;
	
	new_towers := [];
	for key in Keys(accumulated_towers) do
		duplicates := accumulated_towers[key];
		
		level:=0;
		powers:=0;
		current_best := [* *];
		
		for tower in duplicates do
			info := tower[1];
			if (info[4] gt level) or (info[4] eq level and info[5] gt powers) then
				if level ne 0 then
					print "Replaced";
				end if;
				level:=info[4];
				powers:=info[5];
				current_best := tower;
			end if;
		end for;
		
		Append(~new_towers,current_best);
	end for;
	
	return new_towers;
end function;

//given a pattern, find where towers in data have different invariants
//this can easily cause errors as there is no checking about sizes
function find_irregularities(data,pattern,max_level,max_power)
	differences := [ [ 0 : j in [1..max_power+1]] : i in [1..max_level]]; // 0 means no differences
	
	for tower in data do
		// can prove level 1 is always as expected
		for i in [1..max_level] do
			for j in [1..max_power+1] do
				if pattern[i][j] ne tower[2][i][j] then
					differences[i][j] := 1;
				end if;
			end for;
		end for;
	end for;

	return differences;
end function;

//given a pattern, find where towers in data have different invariants (looking at difference from previous level)
//this can easily cause errors as there is no checking about sizes
function find_irregularities_diff(data,pattern,max_level,max_power)
	differences := [ [ 0 : j in [1..max_power+1]] : i in [1..max_level]]; // 0 means no differences
	
	for tower in data do
		// can prove level 1 is always as expected
		for i in [2..max_level] do
			for j in [1..max_power+1] do
				//looking at difference from previous level
				if pattern[i][j]-pattern[i-1][j] ne tower[2][i][j] - tower[2][i-1][j] then
					differences[i][j] := 1;
				end if;
			end for;
		end for;
	end for;

	return differences;
end function;


/* Store and analyze results of computations
<info, data>

info: p,d, description of tower, #levels computed, # powers computed, time spent (in seconds)
data : list of [ genus , dim ker V^1,...] 
*/ 

procedure show_entry(tower)
	info := tower[1];
	data := tower[2];
	print "Tower:", info[3];
	print "p=",info[1],"d=",info[2];
	print "Levels:",info[4];
	print "Genus, dim Ker V, dim Ker V^2...";
	for row in data do
		print row;
	end for;
	print "";
end procedure;

//get p
function get_characteristic(tower)
	return tower[1][1];
end function;

//get d, the ramification invariant of the first level of the tower
function get_ramification_invariant(tower)
	return tower[1][2];
end function;

//get description
function get_name(tower)
	return tower[1][3];
end function;

function get_anumber(tower,level : power:=1)
	assert (level le tower[1][4]);
	assert (power le tower[1][5]);
	return tower[2][level][power+1];
end function;

function get_anumbers(tower : power:=1)
	assert (power le tower[1][5]);
	return [ row[power+1] : row in tower[2] ];
end function;

//get dimension of ker V^{power} / ker V^{power-1} at the nth level
function get_gradeds(tower,power)
	assert (power le tower[1][5]);
	if power eq 1 then
		return get_anumbers(tower);
	end if;
	bigdims := get_anumbers(tower : power:=power);
	smalldims := get_anumbers(tower : power:=power-1);
	return [bigdims[n]-smalldims[n]  :  n in [1..#bigdims]];
end function;

/* Analysis */

/* Guess a formula 
a * q^(2n) + b * q^n + c = a(n)
based on q, and three choices of n
*/
guess:=function(q,ns, as)
	v:=Vector(Rationals(),as);
	N:=Matrix(Rationals(),[[ q^(2*n) , q^n , 1] : n in ns]);
	sol:=Solution(Transpose(N),v);
	return [ sol[1], sol[2], sol[3]];
end function;

//predict additional layers
predict := function(q,n,coeff)
	return coeff[1] * q^(2*n) + coeff[2] * q^(n) + coeff[3] ;
end function;


//guess a formula given p, the dimensions, and which level to start at
function auto_guess(p,vals,start)
	assert( #vals - start ge 0); //otherwise not enough data to guess
		
	v:=Vector(Rationals(),vals[start..(start+2)]);
	N:=Matrix(Rationals(),[[ p^(2*n) , p^n , 1] : n in [start..(start+2)]]);
	sol:=Solution(Transpose(N),v);
	coeff := [ sol[1], sol[2], sol[3]];
	for n in [start+3..#vals] do
		if predict(p,n,coeff) ne vals[n] then
			return coeff, false;
		end if;
	end for;
	
	return coeff,true;
end function;

//make and check a guess for the towers in data
procedure make_guesses(p,data : power:=1)
	for tower in data do
		vals := get_anumbers(tower : power:=power);
		coeff, bool := auto_guess(p,vals,2);
		
		print "Base a-number:",vals[1];
		print "Formula:", coeff[1] ,"*", p, "^(2n)+",coeff[2],"*",p,"^n+",coeff[3];
		print "Consistent?",bool;
	end for;
end procedure;

//In char p >2, a-number level(n+1) = p (p-1) d/ (4 (p+1)) (p^(2n) -1 )  + level1
function conjecture1(p,d,tower)
	conjecture := true;
	if p gt 2 then
		vals := get_anumbers(tower : power:=1);

		a1 := vals[1];
		
		for n in [2..#vals] do
			if p * (p-1) * d / (4 * (p+1)) * (p ^(2*(n-1)) - 1) + a1 ne vals[n] then
				print n,"Predicted:", p * (p-1) * d / (4 * (p+1)) * (p ^(2*(n-1)) - 1) + a1,"Actual:",vals[n];
				conjecture:=false;
			end if;
		end for;
		
		return conjecture;
	else
		vals := get_anumbers(tower : power:=1);

		a1 := vals[1];
		
		for n in [2..#vals] do
			if d/6 * (p ^(2*(n-1)) - 1) + (-1)^((d-1)/2) /2 + a1 ne vals[n] then
				print n,"Predicted:",d/6 * (p ^(2*(n-1)) - 1) + (-1)^((d-1)/2) /2 + a1, "Actual", vals[n];
				conjecture:=false;
			end if;
		end for;

		return conjecture;	
	
	end if;
end function;

procedure test_conjecture1(towers)
	for tower in towers do
		p := get_characteristic(tower);
		d:= get_ramification_invariant(tower);
		name := get_name(tower);
		bool := conjecture1(p,d,tower);
		print "Conjecture1:",p,name,bool;
	end for;
end procedure;

//predict the leading constant for dim ker V^r
//Bryden's conjecture
function predict_leadingconstant(p,d,r)
	if r eq 0 then
		return 0;
	end if;
	if r eq 1 then
		if p gt 2 then
			return  p *(p-1)* d/ (4* (p+1)) ;
		else
			return d/6; //actually the two cases agree as formulated now
		end if;
	end if;
	return (1 + 1/(r-1)) / ( 1 + 1/(r-1+(p+1)/(p-1))) * predict_leadingconstant(p,d,r-1);
end function;

function leading_numerator(p,d,r)
	return Numerator(predict_leadingconstant(p,d,r));
end function;

function leading_denominator(p,d,r)
	return Denominator(predict_leadingconstant(p,d,r));
end function;

function predict_leadingconstant_nod(p,r)
	if r eq 1 then
		if p gt 2 then
			return  p *(p-1)/ (4* (p+1)) ;
		else
			return 1/6; //actually the two cases agree as formulated now
		end if;
	end if;
	return (1 + 1/(r-1)) / ( 1 + 1/(r-1+(p+1)/(p-1))) * predict_leadingconstant_nod(p,r-1);
end function;

//pull out specific examples
function filter_data(data: p := -1 , d:= -1)
	new_data := [];
	for tower in data do
		if ( p eq -1 or p eq get_characteristic(tower)) and ( d eq -1 or d eq get_ramification_invariant(tower)) then
			Append(~new_data,tower);
		end if;
	end for;
	return new_data;
end function;

function predict1(p,d,power,n,a1)
	return predict_leadingconstant(p,d,power)* (p ^(2*(n-1)) - 1) + a1;
end function;

function predict2(p,d,power,n,a1)
	return leading_numerator(p,d,power)* Floor(p ^(2*(n-1)) /leading_denominator(p,d,power)) +a1;
end function;

function predict3(p,d,power,n)
	return Floor(predict_leadingconstant(p,d,power)* (p ^(2*(n-1))));
end function;

procedure display_data(data,p,d : power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_anumbers(tower : power:=power);
		print "dimensions of ker V^",power,":",vals;
		pred1 := [ predict1(p,d,power,n,vals[1]) : n in [1..#vals]];
		print "Predictions1:",pred1;
		print "Delta1s:",[ vals[i] - pred1[i] : i in [1..#vals]];
		pred3 := [ predict3(p,d,power,n) : n in [1..#vals]];
		print "Predictions3:",pred3;		
		print "Delta3s:",[ vals[i] - pred3[i] : i in [1..#vals]];
		print "";
	end for;
end procedure;

procedure display_differences(data,p,d : power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_anumbers(tower : power:=power);
		diffs := [vals[n]-vals[n-1] : n in [2..#vals]];
		print "Differences of ker V^",power,":",diffs;
		pred1 := [ Floor( predict_leadingconstant(p,d,power) * (p^2-1) * p^(2 *(n-1)) ) : n in [1..#vals-1]];
		print "Predictions:",pred1;
		print "Deltas:",[ diffs[i] - pred1[i] : i in [1..#vals-1]];
	end for;
end procedure;

procedure display_gradeds(data,p,d , power)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_gradeds(tower , power);
		print "Dimension of gr ker V^",power,":",vals;
		pred1 := [ Floor( (predict_leadingconstant(p,d,power) - predict_leadingconstant(p,d,power-1) ) * p^(2 *(n-1)) ) : n in [1..#vals]];
		print "Predictions:",pred1;
		print "Deltas:",[ vals[i] - pred1[i] : i in [1..#vals]];
	end for;
end procedure;



procedure display_lots_data(p)
	for d in [2..40] do
		if (d mod 3 ne 0) then
			print "Data for p=",p," d=",d;			
			display_data(p,d);
			print "";
		end if;
	end for;

end procedure;

function find_discrepancies_d(p,d,data)
	discrep := {};
	for tower in data do
		vals := get_anumbers(tower : power:=1);
		pred := [ p * (p-1) * d / (4 * (p+1)) * (p ^(2*(n-1)) - 1) + vals[1] : n in [1..#vals]];
		deltas := [ vals[i] - pred[i] : i in [1..#vals]];
		for i in [2..#vals] do
			if deltas[i] ne deltas[i-1] then
				Include(~discrep,i);
			end if;
		end for;
	end for;
	return discrep;
end function;

function find_discrepancies(p ,data )
	return [ <d,find_discrepancies_d(p,d,filter_data(data : p:=p, d:= d)) > : d in [2..40] | (d mod 3 ne 0) ] ; 
end function;

/* Store and analyze results of computations
<info, data>

info: p,d, description of tower, #levels computed, # powers computed, time spent (in seconds)
data : list of [ genus , dim ker V^1,...] 
*/ 

procedure show_entry(tower)
	info := tower[1];
	data := tower[2];
	print "Tower:", info[3];
	print "p=",info[1],"d=",info[2];
	print "Levels:",info[4];
	print "Genus, dim Ker V, dim Ker V^2...";
	for row in data do
		print row;
	end for;
	print "";
end procedure;

//get p
function get_characteristic(tower)
	return tower[1][1];
end function;

//get d, the ramification invariant of the first level of the tower
function get_ramification_invariant(tower)
	return tower[1][2];
end function;

//get description
function get_name(tower)
	return tower[1][3];
end function;

//get it in a format suitable for latex
function get_name_latex(tower)
	poly := tower[1][3];
	coeff := Coefficients(poly);
	d := #coeff-1;
	coeffstring := ""; if coeff[d+1] ne 1 then coeffstring:=Sprint(coeff[d+1]) ; end if;
	printstring := coeffstring * "x^{" * Sprint(d) * "}";
	
	while d gt 0 do
		d := d-1;
		c := coeff[d+1];
		if c ne 0 then
			coeffstring := ""; if c ne 1 then coeffstring:=Sprint(c) ; end if;
			printstring *:= " +"*coeffstring * "x^{" * Sprint(d) * "}";
		end if;
	end while;
	return printstring;
end function;

function get_anumber(tower,level : power:=1)
	assert (level le tower[1][4]);
	assert (power le tower[1][5]);
	return tower[2][level][power+1];
end function;

function get_anumbers(tower : power:=1)
	assert (power le tower[1][5]);
	return [ row[power+1] : row in tower[2] ];
end function;

//get dimension of ker V^{power} / ker V^{power-1} at the nth level
function get_gradeds(tower,power)
	assert (power le tower[1][5]);
	if power eq 1 then
		return get_anumbers(tower);
	end if;
	bigdims := get_anumbers(tower : power:=power);
	smalldims := get_anumbers(tower : power:=power-1);
	return [bigdims[n]-smalldims[n]  :  n in [1..#bigdims]];
end function;

function get_invariants(tower,level)
	assert( level le tower[1][4]);
	return [tower[2][level][n+1] : n in [1..tower[1][5]]];
end function;

/* Analysis */

/* Guess a formula 
a * q^(2n) + b * q^n + c = a(n)
based on q, and three choices of n
*/
guess:=function(q,ns, as)
	v:=Vector(Rationals(),as);
	N:=Matrix(Rationals(),[[ q^(2*n) , q^n , 1] : n in ns]);
	sol:=Solution(Transpose(N),v);
	return [ sol[1], sol[2], sol[3]];
end function;

//predict additional layers
predict := function(q,n,coeff)
	return coeff[1] * q^(2*n) + coeff[2] * q^(n) + coeff[3] ;
end function;


//guess a formula given p, the dimensions, and which level to start at
function auto_guess(p,vals,start)
	assert( #vals - start ge 0); //otherwise not enough data to guess
		
	v:=Vector(Rationals(),vals[start..(start+2)]);
	N:=Matrix(Rationals(),[[ p^(2*n) , p^n , 1] : n in [start..(start+2)]]);
	sol:=Solution(Transpose(N),v);
	coeff := [ sol[1], sol[2], sol[3]];
	for n in [start+3..#vals] do
		if predict(p,n,coeff) ne vals[n] then
			return coeff, false;
		end if;
	end for;
	
	return coeff,true;
end function;

//make and check a guess for the towers in data
procedure make_guesses(p,data : power:=1)
	for tower in data do
		vals := get_anumbers(tower : power:=power);
		coeff, bool := auto_guess(p,vals,2);
		
		print "Base a-number:",vals[1];
		print "Formula:", coeff[1] ,"*", p, "^(2n)+",coeff[2],"*",p,"^n+",coeff[3];
		print "Consistent?",bool;
	end for;
end procedure;

//In char p >2, a-number level(n+1) = p (p-1) d/ (4 (p+1)) (p^(2n) -1 )  + level1
//This is too strong to be true
function conjecture1(p,d,tower)
	conjecture := true;
	if p gt 2 then
		vals := get_anumbers(tower : power:=1);

		a1 := vals[1];
		
		for n in [2..#vals] do
			if p * (p-1) * d / (4 * (p+1)) * (p ^(2*(n-1)) - 1) + a1 ne vals[n] then
				print n,"Predicted:", p * (p-1) * d / (4 * (p+1)) * (p ^(2*(n-1)) - 1) + a1,"Actual:",vals[n];
				conjecture:=false;
			end if;
		end for;
		
		return conjecture;
	else
		vals := get_anumbers(tower : power:=1);

		a1 := vals[1];
		
		for n in [2..#vals] do
			if d/6 * (p ^(2*(n-1)) - 1) + (-1)^((d-1)/2) /2 + a1 ne vals[n] then
				print n,"Predicted:",d/6 * (p ^(2*(n-1)) - 1) + (-1)^((d-1)/2) /2 + a1, "Actual", vals[n];
				conjecture:=false;
			end if;
		end for;

		return conjecture;	
	
	end if;
end function;

procedure test_conjecture1(towers)
	for tower in towers do
		p := get_characteristic(tower);
		d:= get_ramification_invariant(tower);
		name := get_name(tower);
		bool := conjecture1(p,d,tower);
		print "Conjecture1:",p,name,bool;
	end for;
end procedure;

//predict the leading constant for dim ker V^r
//Bryden's conjecture
function predict_leadingconstant(p,d,r)
	if r eq 0 then
		return 0;
	end if;
	if r eq 1 then
		return  p *(p-1)* d/ (4* (p+1)) ;
	end if;
	return (1 + 1/(r-1)) / ( 1 + 1/(r-1+(p+1)/(p-1))) * predict_leadingconstant(p,d,r-1);
end function;

function leading_numerator(p,d,r)
	return Numerator(predict_leadingconstant(p,d,r));
end function;

function leading_denominator(p,d,r)
	return Denominator(predict_leadingconstant(p,d,r));
end function;

function predict_leadingconstant_nod(p,r)
	if r eq 1 then
		if p gt 2 then
			return  p *(p-1)/ (4* (p+1)) ;
		else
			return 1/6; //actually the two cases agree as formulated now
		end if;
	end if;
	return (1 + 1/(r-1)) / ( 1 + 1/(r-1+(p+1)/(p-1))) * predict_leadingconstant_nod(p,r-1);
end function;

//pull out specific examples
function filter_data(data: p := -1 , d:= -1)
	new_data := [];
	for tower in data do
		if ( p eq -1 or p eq get_characteristic(tower)) and ( d eq -1 or d eq get_ramification_invariant(tower)) then
			Append(~new_data,tower);
		end if;
	end for;
	return new_data;
end function;

/*Some attempts at predicting the formula
*/
//this needs power \equiv 1 \mod p, so always get an integer
function predict1(p,d,power,n,a1)
	return predict_leadingconstant(p,d,power)* (p ^(2*(n-1)) - 1) + a1;
end function;

//predict floor of leading term
function predict2(p,d,power,n)
	return Floor(predict_leadingconstant(p,d,power)* (p ^(2*(n-1))));
end function;

//take into account first level
function predict3(p,d,power,n,a1)
	return Floor(predict_leadingconstant(p,d,power)* (p ^(2*(n-1)))) +a1;
end function;

/*the following look for all of the towers in data with given (p,d) and display some predictions and errors about the invariants
*/
procedure display_data(data,p,d : power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_anumbers(tower : power:=power);
		print "dimensions of ker V^",power,":",vals;
		pred1 := [ predict1(p,d,power,n,vals[1]) : n in [1..#vals]];
		print "Predictions1:",pred1;
		pred2 := [ predict2(p,d,power,n) : n in [1..#vals]];
		print "Predictions2:",pred2;
		print "Delta2s:",[ vals[i] - pred2[i] : i in [1..#vals]];	
		pred3 := [ predict3(p,d,power,n,vals[1]) : n in [1..#vals]];
		print "Predictions3:",pred3;		
		print "Delta3s:",[ vals[i] - pred3[i] : i in [1..#vals]];
		print "";
	end for;
end procedure;

procedure display_differences(data,p,d : power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_anumbers(tower : power:=power);
		diffs := [vals[n]-vals[n-1] : n in [2..#vals]];
		print "Differences of ker V^",power,":",diffs;
		pred1 := [ Floor( predict_leadingconstant(p,d,power) * (p^2-1) * p^(2 *(n-1)) ) : n in [1..#vals-1]];
		print "Predictions:",pred1;
		print "Deltas:",[ diffs[i] - pred1[i] : i in [1..#vals-1]];
	end for;
end procedure;

procedure display_gradeds(data,p,d , power)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do
		print "Tower:", get_name(tower);
		vals := get_gradeds(tower , power);
		print "Dimension of gr ker V^",power,":",vals;
		pred1 := [ Floor( (predict_leadingconstant(p,d,power) - predict_leadingconstant(p,d,power-1) ) * p^(2 *(n-1)) ) : n in [1..#vals]];
		print "Predictions:",pred1;
		print "Deltas:",[ vals[i] - pred1[i] : i in [1..#vals]];
	end for;
end procedure;



procedure display_lots_data(p)
	for d in [2..40] do
		if (d mod 3 ne 0) then
			print "Data for p=",p," d=",d;			
			display_data(p,d);
			print "";
		end if;
	end for;

end procedure;

function find_discrepancies_d(p,d,data)
	discrep := {};
	for tower in data do
		vals := get_anumbers(tower : power:=1);
		pred := [ p * (p-1) * d / (4 * (p+1)) * (p ^(2*(n-1)) - 1) + vals[1] : n in [1..#vals]];
		deltas := [ vals[i] - pred[i] : i in [1..#vals]];
		for i in [2..#vals] do
			if deltas[i] ne deltas[i-1] then
				Include(~discrep,i);
			end if;
		end for;
	end for;
	return discrep;
end function;

function find_discrepancies(p ,data )
	return [ <d,find_discrepancies_d(p,d,filter_data(data : p:=p, d:= d)) > : d in [2..40] | (d mod 3 ne 0) ] ; 
end function;

/* Functions for Creating LaTeX tables
Requires the package booktabs for nicer formatting */
/*
\begin{table}[ht]
\centering
\begin{tabular}[c| c....c]
header
\toprule
labels & data
\bottomrule
\end{tabular}
\caption{ caption }
\end{table}
*/
function format_table(header,labels,data,caption)
	columns := #header;
	preamble := "\\begin{table}[ht]\n\\centering\n\\begin{tabular}{c|";
	
	for n in [1..columns] do
		preamble *:= "c ";
	end for;
	preamble *:= "}\n";
	
	headerstring := Sprint(header[1]);
	for n in [2..columns] do
		headerstring *:=" & " * Sprint(header[n]);
	end for;
	headerstring *:= " \\\\ \n\\toprule\n";
	
	mainstring := "";
	for n in [1..#labels] do
		rowstring := Sprint(labels[n]);
		for item in data[n] do
			rowstring *:= " & " * Sprint(item);
		end for;
		mainstring *:= rowstring * " \\\\ \n";
	end for;
	
	finalstring := "\\bottomrule\n\\end{tabular}\n\\caption{" * Sprint(caption) * "}\n\\end{table}";
	
	return preamble * headerstring * mainstring * finalstring;
end function;

//style 1, displaying genus, dim ker V^r
function tower_table1(tower : maxlevel:=1000, maxpower:=1000)
	info := tower[1];
	data := tower[2];
	levels := Min(info[4],maxlevel);
	powers := Min(info[5],maxpower);

	header := ["Level", "Genus"] cat [ "dim ker $V^{" *Sprint(n) *"}$": n in [1..powers]];
	
	labels := [1..levels];
	data := [  [data[l][r] : r in [1..powers+1]] : l in [1..levels] ];
	
	caption := "$y^F-y="*Sprint(get_name_latex(tower)) * "$ with $(p,d) = (" * Sprint(get_characteristic(tower))*"," * Sprint(get_ramification_invariant(tower)) * ")$";
	return format_table(header,labels,data,caption);
end function;

//style 2, with levels in columns
function tower_table2(tower : maxlevel:=1000, maxpower:=1000)
	info := tower[1];
	data := tower[2];
	levels := Min(info[4],maxlevel);
	powers := Min(info[5],maxpower);

	labels := [ "Genus"] cat [ "dim ker $V^{" *Sprint(n) *"}$": n in [1..powers]];
	
	header := ["Level:"] cat [ Sprint(n) : n in [1..levels]];
	data := [  [data[l][r] : l in [1..levels]] : r in [1..powers+1] ];
	
	caption := "$y^F-y="*Sprint(get_name_latex(tower)) * "$ with $(p,d) = (" * Sprint(get_characteristic(tower))*"," * Sprint(get_ramification_invariant(tower)) * ")$";
	return format_table(header,labels,data,caption);
end function;


//make tables displaying predictions for values
procedure table_data(data,p,d: power:=1)
	new_data := filter_data(data : p :=p, d:= d);
	for tower in new_data do	
		info := tower[1];
		data := tower[2];
		levels := info[4];

		labels := [ "Actual", "Pred1","Pred2","Delta2","Pred3","Delta3"];
		
		header := ["Level:"] cat [ Sprint(n) : n in [1..levels]];
		vals:=get_anumbers(tower : power:=power) ;
		pred1 := [ predict1(p,d,power,n,vals[1]) : n in [1..#vals]];
		pred2 := [ predict2(p,d,power,n) : n in [1..#vals]];
		pred3 := [ predict3(p,d,power,n,vals[1]) : n in [1..#vals]];
		data := [ vals, pred1,pred2,
			[ vals[i] - pred2[i] : i in [1..#vals]],
			pred3, [ vals[i] - pred3[i] : i in [1..#vals]]
			];

		
		caption := "$y^F-y="*Sprint(get_name_latex(tower)) * "$ with $(p,d) = (" * Sprint(get_characteristic(tower))*"," * Sprint(get_ramification_invariant(tower)) * ")$";
		print format_table(header,labels,data,caption);
		print "";
	end for;
end procedure;

/*
In case same computation gets run multiple times (with different depth perhaps), remove duplicates
*/
remove_duplicate_data := function(data)
	accumulated_towers := AssociativeArray();
	for tower in data do
		p := get_characteristic(tower);
		poly := get_name(tower);
		key := <p,poly>;
		if key in Keys(accumulated_towers) then
			Append(~accumulated_towers[key],tower);
			print "Had duplicate:",key;
			print "";
		else
			accumulated_towers[key] := [tower];
		end if;
	end for;
	
	new_towers := [];
	for key in Keys(accumulated_towers) do
		duplicates := accumulated_towers[key];
		
		level:=0;
		powers:=0;
		current_best := [* *];
		
		for tower in duplicates do
			info := tower[1];
			if (info[4] gt level) or (info[4] eq level and info[5] gt powers) then
				if level ne 0 then
					print "Replaced";
				end if;
				level:=info[4];
				powers:=info[5];
				current_best := tower;
			end if;
		end for;
		
		Append(~new_towers,current_best);
	end for;
	
	return new_towers;
end function;

